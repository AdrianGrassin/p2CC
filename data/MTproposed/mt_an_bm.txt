# MT para L = { a^n b^m | m > n, n > 0 }
q0 q1 q2 qF qR
a b
a b X Y .
q0
.
qF
# δ: Transiciones
# --- INICIO (n > 0) ---
# Si leemos 'a', n>0 se cumple. Marcamos X, vamos a q1 a buscar un b.
q0 a q1 X R
# Si leemos 'b' (n=0) o '.' (vacío), rechazamos (qR).
q0 b qR b R
q0 . qR . R

# --- BUCLE DE MARCADO (q1 -> q2 -> q0) ---
# q1: Buscar b (moviéndose a la derecha)
# Omitimos a's y Y's (b's ya marcadas)
q1 a q1 a R
q1 Y q1 Y R
# Encontramos la primera b sin marcar. La marcamos Y y retrocedemos (q2)
q1 b q2 Y L
# Si llegamos al final (blanco) buscando b, significa n > m. Rechazamos (qR).
q1 . qR . R

# q2: Retroceder (moviéndose a la izquierda)
# Omitimos a's, b's, y Y's hasta encontrar la X que pusimos
q2 a q2 a L
q2 b q2 b L
q2 Y q2 Y L
# Encontramos la X. Nos movemos a la derecha para prepararnos para la siguiente a.
q2 X q0 X R

# --- VERIFICACIÓN FINAL (q0 decide) ---
# q0: Cabeza en la a siguiente (o Y si se acabaron las a's)
# (Si q0 vuelve a ver una 'a', el bucle `q0 a q1 X R` se encarga)

# Omitimos Y's (b's ya marcadas)
q0 Y q0 Y R

# Si q0 (después de las Y) ve una b, significa m > n. ACEPTAR.
q0 b qF b R

# Si q0 (después de las Y) ve '.', significa n = m. RECHAZAR.
q0 . qR . R


# (NOTA: No hay transiciones definidas para qR.
#  La máquina se detendrá automáticamente (y rechazará) al entrar en qR)